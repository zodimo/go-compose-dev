//go:build ignore
// +build ignore

// This program generates symbols.go by downloading the Material Symbols codepoints
// from Google's Material Design Icons repository.
//
// Usage: go generate ./compose/material3/icon/...

package main

import (
	"bufio"
	"fmt"
	"net/http"
	"os"
	"strings"
	"unicode"
)

const codepointsURL = "https://raw.githubusercontent.com/google/material-design-icons/master/variablefont/MaterialSymbolsOutlined%5BFILL%2CGRAD%2Copsz%2Cwght%5D.codepoints"

func main() {
	// Download the codepoints file
	resp, err := http.Get(codepointsURL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to download codepoints: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Fprintf(os.Stderr, "Failed to download codepoints: HTTP %d\n", resp.StatusCode)
		os.Exit(1)
	}

	// Parse the codepoints
	type iconEntry struct {
		name      string
		codepoint string
	}
	var icons []iconEntry

	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) != 2 {
			continue
		}
		icons = append(icons, iconEntry{name: parts[0], codepoint: parts[1]})
	}

	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read codepoints: %v\n", err)
		os.Exit(1)
	}

	// Generate the Go file
	out, err := os.Create("symbols.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create symbols.go: %v\n", err)
		os.Exit(1)
	}
	defer out.Close()

	fmt.Fprintln(out, "// Code generated by gen_symbols.go; DO NOT EDIT.")
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "package icon")
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "// SymbolName represents a Material Symbol icon name.")
	fmt.Fprintln(out, "// Use these constants with the Symbol composable to avoid typos.")
	fmt.Fprintln(out, "type SymbolName string")
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "// Material Symbol icon constants.")
	fmt.Fprintln(out, "// Generated from:", codepointsURL)
	fmt.Fprintln(out, "const (")

	for _, icon := range icons {
		constName := toGoConstName(icon.name)
		fmt.Fprintf(out, "\tSymbol%s SymbolName = %q\n", constName, icon.name)
	}

	fmt.Fprintln(out, ")")

	fmt.Printf("Generated symbols.go with %d icons\n", len(icons))
}

// toGoConstName converts a snake_case icon name to PascalCase.
// e.g., "add_circle" -> "AddCircle", "3d_rotation" -> "3dRotation"
func toGoConstName(name string) string {
	parts := strings.Split(name, "_")
	var result strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		// Handle leading digits - just capitalize first letter after
		runes := []rune(part)
		if len(runes) > 0 {
			runes[0] = unicode.ToUpper(runes[0])
		}
		result.WriteString(string(runes))
	}
	return result.String()
}
